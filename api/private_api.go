/*
 * MAX RESTful API List
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package api

import (
	"context"
	"encoding/json"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type PrivateApiService service

/* PrivateApiService
get details of a specific deposit
* @param ctx context.Context for authentication, logging, tracing, etc.
@param xMAXACCESSKEY access key
@param xMAXPAYLOAD encoded payload
@param xMAXSIGNATURE encrypted signature
@param txid unique transaction id
@return Deposit*/
func (a *PrivateApiService) GetApiV2Deposit(ctx context.Context, xMAXACCESSKEY string, xMAXPAYLOAD string, xMAXSIGNATURE string, txid string) (Deposit, *http.Response, error) {
	var (
		localVarHTTPMethod = strings.ToUpper("Get")
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     Deposit
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/deposit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	localVarPostBody := make(map[string]interface{})

	localVarQueryParams.Add("txid", parameterToString(txid, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-MAX-ACCESSKEY"] = parameterToString(xMAXACCESSKEY, "")
	localVarHeaderParams["X-MAX-PAYLOAD"] = parameterToString(xMAXPAYLOAD, "")
	localVarHeaderParams["X-MAX-SIGNATURE"] = parameterToString(xMAXSIGNATURE, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return successPayload, localVarHTTPResponse, err
	}
	defer localVarHTTPResponse.Body.Close()
	if localVarHTTPResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHTTPResponse.Body)
		return successPayload, localVarHTTPResponse, reportError("Status: %v, Body: %s", localVarHTTPResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHTTPResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHTTPResponse, err
	}

	return successPayload, localVarHTTPResponse, err
}

/* PrivateApiService where to deposit
The address could be empty when a new one is generating, try again later in that case.
* @param ctx context.Context for authentication, logging, tracing, etc.
@param xMAXACCESSKEY access key
@param xMAXPAYLOAD encoded payload
@param xMAXSIGNATURE encrypted signature
@param optional (nil or map[string]interface{}) with one or more of:
    @param "currency" (string) unique currency id, check /api/v2/currencies for available currencies
@return []PaymentAddress*/
func (a *PrivateApiService) GetApiV2DepositAddress(ctx context.Context, xMAXACCESSKEY string, xMAXPAYLOAD string, xMAXSIGNATURE string, localVarOptionals map[string]interface{}) ([]PaymentAddress, *http.Response, error) {
	var (
		localVarHTTPMethod = strings.ToUpper("Get")
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     []PaymentAddress
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/deposit_address"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	localVarPostBody := make(map[string]interface{})

	if err := typeCheckParameter(localVarOptionals["currency"], "string", "currency"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["currency"].(string); localVarOk {
		localVarQueryParams.Add("currency", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-MAX-ACCESSKEY"] = parameterToString(xMAXACCESSKEY, "")
	localVarHeaderParams["X-MAX-PAYLOAD"] = parameterToString(xMAXPAYLOAD, "")
	localVarHeaderParams["X-MAX-SIGNATURE"] = parameterToString(xMAXSIGNATURE, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return successPayload, localVarHTTPResponse, err
	}
	defer localVarHTTPResponse.Body.Close()
	if localVarHTTPResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHTTPResponse.Body)
		return successPayload, localVarHTTPResponse, reportError("Status: %v, Body: %s", localVarHTTPResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHTTPResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHTTPResponse, err
	}

	return successPayload, localVarHTTPResponse, err
}

/* PrivateApiService where to deposit
The addresses could be empty before generated, please call POST /deposit_addresses in that case
* @param ctx context.Context for authentication, logging, tracing, etc.
@param xMAXACCESSKEY access key
@param xMAXPAYLOAD encoded payload
@param xMAXSIGNATURE encrypted signature
@param optional (nil or map[string]interface{}) with one or more of:
    @param "currency" (string) unique currency id, check /api/v2/currencies for available currencies
@return []PaymentAddress*/
func (a *PrivateApiService) GetApiV2DepositAddresses(ctx context.Context, xMAXACCESSKEY string, xMAXPAYLOAD string, xMAXSIGNATURE string, localVarOptionals map[string]interface{}) ([]PaymentAddress, *http.Response, error) {
	var (
		localVarHTTPMethod = strings.ToUpper("Get")
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     []PaymentAddress
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/deposit_addresses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	localVarPostBody := make(map[string]interface{})

	if err := typeCheckParameter(localVarOptionals["currency"], "string", "currency"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["currency"].(string); localVarOk {
		localVarQueryParams.Add("currency", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-MAX-ACCESSKEY"] = parameterToString(xMAXACCESSKEY, "")
	localVarHeaderParams["X-MAX-PAYLOAD"] = parameterToString(xMAXPAYLOAD, "")
	localVarHeaderParams["X-MAX-SIGNATURE"] = parameterToString(xMAXSIGNATURE, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return successPayload, localVarHTTPResponse, err
	}
	defer localVarHTTPResponse.Body.Close()
	if localVarHTTPResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHTTPResponse.Body)
		return successPayload, localVarHTTPResponse, reportError("Status: %v, Body: %s", localVarHTTPResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHTTPResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHTTPResponse, err
	}

	return successPayload, localVarHTTPResponse, err
}

/* PrivateApiService
get your deposits history
* @param ctx context.Context for authentication, logging, tracing, etc.
@param xMAXACCESSKEY access key
@param xMAXPAYLOAD encoded payload
@param xMAXSIGNATURE encrypted signature
@param optional (nil or map[string]interface{}) with one or more of:
    @param "currency" (string) unique currency id, check /api/v2/currencies for available currencies
    @param "from" (int32) target period start (Epoch time in seconds)
    @param "to" (int32) target period end (Epoch time in seconds)
    @param "state" (string)
    @param "pagination" (bool) do pagination &amp; return metadata in header (default false)
    @param "page" (int32) page number, applied for pagination (default 1)
    @param "limit" (int32) returned limit (1~1000, default 50)
    @param "offset" (int32) records to skip, not applied for pagination (default 0)
@return []Deposit*/
func (a *PrivateApiService) GetApiV2Deposits(ctx context.Context, xMAXACCESSKEY string, xMAXPAYLOAD string, xMAXSIGNATURE string, localVarOptionals map[string]interface{}) ([]Deposit, *http.Response, error) {
	var (
		localVarHTTPMethod = strings.ToUpper("Get")
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     []Deposit
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/deposits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	localVarPostBody := make(map[string]interface{})

	if err := typeCheckParameter(localVarOptionals["currency"], "string", "currency"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["from"], "int32", "from"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["to"], "int32", "to"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["state"], "string", "state"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["pagination"], "bool", "pagination"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["page"], "int32", "page"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["limit"], "int32", "limit"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["offset"], "int32", "offset"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["currency"].(string); localVarOk {
		localVarQueryParams.Add("currency", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["from"].(int32); localVarOk {
		localVarQueryParams.Add("from", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["to"].(int32); localVarOk {
		localVarQueryParams.Add("to", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["state"].(string); localVarOk {
		localVarQueryParams.Add("state", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["pagination"].(bool); localVarOk {
		localVarQueryParams.Add("pagination", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["page"].(int32); localVarOk {
		localVarQueryParams.Add("page", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["limit"].(int32); localVarOk {
		localVarQueryParams.Add("limit", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["offset"].(int32); localVarOk {
		localVarQueryParams.Add("offset", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-MAX-ACCESSKEY"] = parameterToString(xMAXACCESSKEY, "")
	localVarHeaderParams["X-MAX-PAYLOAD"] = parameterToString(xMAXPAYLOAD, "")
	localVarHeaderParams["X-MAX-SIGNATURE"] = parameterToString(xMAXSIGNATURE, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return successPayload, localVarHTTPResponse, err
	}
	defer localVarHTTPResponse.Body.Close()
	if localVarHTTPResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHTTPResponse.Body)
		return successPayload, localVarHTTPResponse, reportError("Status: %v, Body: %s", localVarHTTPResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHTTPResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHTTPResponse, err
	}

	return successPayload, localVarHTTPResponse, err
}

/* PrivateApiService
get your profile and accounts infomation
* @param ctx context.Context for authentication, logging, tracing, etc.
@param xMAXACCESSKEY access key
@param xMAXPAYLOAD encoded payload
@param xMAXSIGNATURE encrypted signature
@return Member*/
func (a *PrivateApiService) GetApiV2MembersMe(ctx context.Context, xMAXACCESSKEY string, xMAXPAYLOAD string, xMAXSIGNATURE string) (Member, *http.Response, error) {
	var (
		localVarHTTPMethod = strings.ToUpper("Get")
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     Member
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/members/me"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	localVarPostBody := make(map[string]interface{})

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-MAX-ACCESSKEY"] = parameterToString(xMAXACCESSKEY, "")
	localVarHeaderParams["X-MAX-PAYLOAD"] = parameterToString(xMAXPAYLOAD, "")
	localVarHeaderParams["X-MAX-SIGNATURE"] = parameterToString(xMAXSIGNATURE, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return successPayload, localVarHTTPResponse, err
	}
	defer localVarHTTPResponse.Body.Close()
	if localVarHTTPResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHTTPResponse.Body)
		return successPayload, localVarHTTPResponse, reportError("Status: %v, Body: %s", localVarHTTPResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHTTPResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHTTPResponse, err
	}

	return successPayload, localVarHTTPResponse, err
}

/* PrivateApiService
get a specific order.
* @param ctx context.Context for authentication, logging, tracing, etc.
@param xMAXACCESSKEY access key
@param xMAXPAYLOAD encoded payload
@param xMAXSIGNATURE encrypted signature
@param id unique order id
@return Order*/
func (a *PrivateApiService) GetApiV2Order(ctx context.Context, xMAXACCESSKEY string, xMAXPAYLOAD string, xMAXSIGNATURE string, id int32) (Order, *http.Response, error) {
	var (
		localVarHTTPMethod = strings.ToUpper("Get")
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     Order
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	localVarPostBody := make(map[string]interface{})

	localVarQueryParams.Add("id", parameterToString(id, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-MAX-ACCESSKEY"] = parameterToString(xMAXACCESSKEY, "")
	localVarHeaderParams["X-MAX-PAYLOAD"] = parameterToString(xMAXPAYLOAD, "")
	localVarHeaderParams["X-MAX-SIGNATURE"] = parameterToString(xMAXSIGNATURE, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return successPayload, localVarHTTPResponse, err
	}
	defer localVarHTTPResponse.Body.Close()
	if localVarHTTPResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHTTPResponse.Body)
		return successPayload, localVarHTTPResponse, reportError("Status: %v, Body: %s", localVarHTTPResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHTTPResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHTTPResponse, err
	}

	return successPayload, localVarHTTPResponse, err
}

/* PrivateApiService
get your orders, results is paginated.
* @param ctx context.Context for authentication, logging, tracing, etc.
@param xMAXACCESSKEY access key
@param xMAXPAYLOAD encoded payload
@param xMAXSIGNATURE encrypted signature
@param market unique market id, check /api/v2/markets for available markets
@param optional (nil or map[string]interface{}) with one or more of:
    @param "state" (string) filter by state, default to &#39;wait&#39;
    @param "orderBy" (string) order in created time, default to &#39;asc&#39;.
    @param "pagination" (bool) do pagination &amp; return metadata in header (default true)
    @param "page" (int32) page number, applied for pagination (default 1)
    @param "limit" (int32) returned limit (1~1000, default 100)
    @param "offset" (int32) records to skip, not applied for pagination (default 0)
@return []Order*/
func (a *PrivateApiService) GetApiV2Orders(ctx context.Context, xMAXACCESSKEY string, xMAXPAYLOAD string, xMAXSIGNATURE string, market string, localVarOptionals map[string]interface{}) ([]Order, *http.Response, error) {
	var (
		localVarHTTPMethod = strings.ToUpper("Get")
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     []Order
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	localVarPostBody := make(map[string]interface{})

	if err := typeCheckParameter(localVarOptionals["state"], "string", "state"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["order_by"], "string", "order_by"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["pagination"], "bool", "pagination"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["page"], "int32", "page"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["limit"], "int32", "limit"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["offset"], "int32", "offset"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("market", parameterToString(market, ""))
	if localVarTempParam, localVarOk := localVarOptionals["state"].(string); localVarOk {
		localVarQueryParams.Add("state", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["order_by"].(string); localVarOk {
		localVarQueryParams.Add("order_by", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["pagination"].(bool); localVarOk {
		localVarQueryParams.Add("pagination", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["page"].(int32); localVarOk {
		localVarQueryParams.Add("page", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["limit"].(int32); localVarOk {
		localVarQueryParams.Add("limit", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["offset"].(int32); localVarOk {
		localVarQueryParams.Add("offset", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-MAX-ACCESSKEY"] = parameterToString(xMAXACCESSKEY, "")
	localVarHeaderParams["X-MAX-PAYLOAD"] = parameterToString(xMAXPAYLOAD, "")
	localVarHeaderParams["X-MAX-SIGNATURE"] = parameterToString(xMAXSIGNATURE, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return successPayload, localVarHTTPResponse, err
	}
	defer localVarHTTPResponse.Body.Close()
	if localVarHTTPResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHTTPResponse.Body)
		return successPayload, localVarHTTPResponse, reportError("Status: %v, Body: %s", localVarHTTPResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHTTPResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHTTPResponse, err
	}

	return successPayload, localVarHTTPResponse, err
}

/* PrivateApiService
get your executed trades, sorted in reverse creation order
* @param ctx context.Context for authentication, logging, tracing, etc.
@param xMAXACCESSKEY access key
@param xMAXPAYLOAD encoded payload
@param xMAXSIGNATURE encrypted signature
@param market unique market id, check /api/v2/markets for available markets
@param optional (nil or map[string]interface{}) with one or more of:
    @param "timestamp" (int32) the seconds elapsed since Unix epoch, set to return trades executed before the time only
    @param "from" (int32) trade id, set ot return trades created after the trade
    @param "to" (int32) trade id, set to return trades created before the trade
    @param "orderBy" (string) order the trades by created time, default to &#39;desc&#39;
    @param "pagination" (bool) do pagination &amp; return metadata in header (default true)
    @param "page" (int32) page number, applied for pagination (default 1)
    @param "limit" (int32) returned limit (1~1000, default 50)
    @param "offset" (int32) records to skip, not applied for pagination (default 0)
@return []Trade*/
func (a *PrivateApiService) GetApiV2TradesMy(ctx context.Context, xMAXACCESSKEY string, xMAXPAYLOAD string, xMAXSIGNATURE string, market string, localVarOptionals map[string]interface{}) ([]Trade, *http.Response, error) {
	var (
		localVarHTTPMethod = strings.ToUpper("Get")
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     []Trade
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/trades/my"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	localVarPostBody := make(map[string]interface{})

	if err := typeCheckParameter(localVarOptionals["timestamp"], "int32", "timestamp"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["from"], "int32", "from"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["to"], "int32", "to"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["order_by"], "string", "order_by"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["pagination"], "bool", "pagination"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["page"], "int32", "page"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["limit"], "int32", "limit"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["offset"], "int32", "offset"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("market", parameterToString(market, ""))
	if localVarTempParam, localVarOk := localVarOptionals["timestamp"].(int32); localVarOk {
		localVarQueryParams.Add("timestamp", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["from"].(int32); localVarOk {
		localVarQueryParams.Add("from", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["to"].(int32); localVarOk {
		localVarQueryParams.Add("to", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["order_by"].(string); localVarOk {
		localVarQueryParams.Add("order_by", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["pagination"].(bool); localVarOk {
		localVarQueryParams.Add("pagination", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["page"].(int32); localVarOk {
		localVarQueryParams.Add("page", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["limit"].(int32); localVarOk {
		localVarQueryParams.Add("limit", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["offset"].(int32); localVarOk {
		localVarQueryParams.Add("offset", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-MAX-ACCESSKEY"] = parameterToString(xMAXACCESSKEY, "")
	localVarHeaderParams["X-MAX-PAYLOAD"] = parameterToString(xMAXPAYLOAD, "")
	localVarHeaderParams["X-MAX-SIGNATURE"] = parameterToString(xMAXSIGNATURE, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return successPayload, localVarHTTPResponse, err
	}
	defer localVarHTTPResponse.Body.Close()
	if localVarHTTPResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHTTPResponse.Body)
		return successPayload, localVarHTTPResponse, reportError("Status: %v, Body: %s", localVarHTTPResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHTTPResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHTTPResponse, err
	}

	return successPayload, localVarHTTPResponse, err
}

/* PrivateApiService
get details of a specific withdraw
* @param ctx context.Context for authentication, logging, tracing, etc.
@param xMAXACCESSKEY access key
@param xMAXPAYLOAD encoded payload
@param xMAXSIGNATURE encrypted signature
@param uuid unique withdraw id
@return Withdrawal*/
func (a *PrivateApiService) GetApiV2Withdrawal(ctx context.Context, xMAXACCESSKEY string, xMAXPAYLOAD string, xMAXSIGNATURE string, uuid string) (Withdrawal, *http.Response, error) {
	var (
		localVarHTTPMethod = strings.ToUpper("Get")
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     Withdrawal
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/withdrawal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	localVarPostBody := make(map[string]interface{})

	localVarQueryParams.Add("uuid", parameterToString(uuid, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-MAX-ACCESSKEY"] = parameterToString(xMAXACCESSKEY, "")
	localVarHeaderParams["X-MAX-PAYLOAD"] = parameterToString(xMAXPAYLOAD, "")
	localVarHeaderParams["X-MAX-SIGNATURE"] = parameterToString(xMAXSIGNATURE, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return successPayload, localVarHTTPResponse, err
	}
	defer localVarHTTPResponse.Body.Close()
	if localVarHTTPResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHTTPResponse.Body)
		return successPayload, localVarHTTPResponse, reportError("Status: %v, Body: %s", localVarHTTPResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHTTPResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHTTPResponse, err
	}

	return successPayload, localVarHTTPResponse, err
}

/* PrivateApiService
get your withdrawals history
* @param ctx context.Context for authentication, logging, tracing, etc.
@param xMAXACCESSKEY access key
@param xMAXPAYLOAD encoded payload
@param xMAXSIGNATURE encrypted signature
@param optional (nil or map[string]interface{}) with one or more of:
    @param "currency" (string) unique currency id, check /api/v2/currencies for available currencies
    @param "from" (int32) target period start (Epoch time in seconds)
    @param "to" (int32) target period end (Epoch time in seconds)
    @param "state" (string)
    @param "pagination" (bool) do pagination &amp; return metadata in header (default false)
    @param "page" (int32) page number, applied for pagination (default 1)
    @param "limit" (int32) returned limit (1~1000, default 50)
    @param "offset" (int32) records to skip, not applied for pagination (default 0)
@return []Withdrawal*/
func (a *PrivateApiService) GetApiV2Withdrawals(ctx context.Context, xMAXACCESSKEY string, xMAXPAYLOAD string, xMAXSIGNATURE string, localVarOptionals map[string]interface{}) ([]Withdrawal, *http.Response, error) {
	var (
		localVarHTTPMethod = strings.ToUpper("Get")
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     []Withdrawal
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/withdrawals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	localVarPostBody := make(map[string]interface{})

	if err := typeCheckParameter(localVarOptionals["currency"], "string", "currency"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["from"], "int32", "from"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["to"], "int32", "to"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["state"], "string", "state"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["pagination"], "bool", "pagination"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["page"], "int32", "page"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["limit"], "int32", "limit"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["offset"], "int32", "offset"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["currency"].(string); localVarOk {
		localVarQueryParams.Add("currency", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["from"].(int32); localVarOk {
		localVarQueryParams.Add("from", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["to"].(int32); localVarOk {
		localVarQueryParams.Add("to", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["state"].(string); localVarOk {
		localVarQueryParams.Add("state", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["pagination"].(bool); localVarOk {
		localVarQueryParams.Add("pagination", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["page"].(int32); localVarOk {
		localVarQueryParams.Add("page", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["limit"].(int32); localVarOk {
		localVarQueryParams.Add("limit", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["offset"].(int32); localVarOk {
		localVarQueryParams.Add("offset", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-MAX-ACCESSKEY"] = parameterToString(xMAXACCESSKEY, "")
	localVarHeaderParams["X-MAX-PAYLOAD"] = parameterToString(xMAXPAYLOAD, "")
	localVarHeaderParams["X-MAX-SIGNATURE"] = parameterToString(xMAXSIGNATURE, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return successPayload, localVarHTTPResponse, err
	}
	defer localVarHTTPResponse.Body.Close()
	if localVarHTTPResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHTTPResponse.Body)
		return successPayload, localVarHTTPResponse, reportError("Status: %v, Body: %s", localVarHTTPResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHTTPResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHTTPResponse, err
	}

	return successPayload, localVarHTTPResponse, err
}

/* PrivateApiService create deposit addresses
Address creation is asynchronous, please call GET /deposit_addresses later to get generated addresses
* @param ctx context.Context for authentication, logging, tracing, etc.
@param xMAXACCESSKEY access key
@param xMAXPAYLOAD encoded payload
@param xMAXSIGNATURE encrypted signature
@param currency unique currency id, check /api/v2/currencies for available currencies
@return []PaymentAddress*/
func (a *PrivateApiService) PostApiV2DepositAddresses(ctx context.Context, xMAXACCESSKEY string, xMAXPAYLOAD string, xMAXSIGNATURE string, currency string) ([]PaymentAddress, *http.Response, error) {
	var (
		localVarHTTPMethod = strings.ToUpper("Post")
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     []PaymentAddress
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/deposit_addresses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	localVarPostBody := make(map[string]interface{})

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-MAX-ACCESSKEY"] = parameterToString(xMAXACCESSKEY, "")
	localVarHeaderParams["X-MAX-PAYLOAD"] = parameterToString(xMAXPAYLOAD, "")
	localVarHeaderParams["X-MAX-SIGNATURE"] = parameterToString(xMAXSIGNATURE, "")
	localVarPostBody["currency"] = parameterToString(currency, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return successPayload, localVarHTTPResponse, err
	}
	defer localVarHTTPResponse.Body.Close()
	if localVarHTTPResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHTTPResponse.Body)
		return successPayload, localVarHTTPResponse, reportError("Status: %v, Body: %s", localVarHTTPResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHTTPResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHTTPResponse, err
	}

	return successPayload, localVarHTTPResponse, err
}

/* PrivateApiService
cancel an order
* @param ctx context.Context for authentication, logging, tracing, etc.
@param xMAXACCESSKEY access key
@param xMAXPAYLOAD encoded payload
@param xMAXSIGNATURE encrypted signature
@param id unique order id
@return Order*/
func (a *PrivateApiService) PostApiV2OrderDelete(ctx context.Context, xMAXACCESSKEY string, xMAXPAYLOAD string, xMAXSIGNATURE string, id int32) (Order, *http.Response, error) {
	var (
		localVarHTTPMethod = strings.ToUpper("Post")
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     Order
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/order/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	localVarPostBody := make(map[string]interface{})

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-MAX-ACCESSKEY"] = parameterToString(xMAXACCESSKEY, "")
	localVarHeaderParams["X-MAX-PAYLOAD"] = parameterToString(xMAXPAYLOAD, "")
	localVarHeaderParams["X-MAX-SIGNATURE"] = parameterToString(xMAXSIGNATURE, "")
	localVarPostBody["id"] = parameterToString(id, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return successPayload, localVarHTTPResponse, err
	}
	defer localVarHTTPResponse.Body.Close()
	if localVarHTTPResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHTTPResponse.Body)
		return successPayload, localVarHTTPResponse, reportError("Status: %v, Body: %s", localVarHTTPResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHTTPResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHTTPResponse, err
	}

	return successPayload, localVarHTTPResponse, err
}

/* PrivateApiService
create a sell/buy order
* @param ctx context.Context for authentication, logging, tracing, etc.
@param xMAXACCESSKEY access key
@param xMAXPAYLOAD encoded payload
@param xMAXSIGNATURE encrypted signature
@param market unique market id, check /api/v2/markets for available markets
@param side &#39;sell&#39; or &#39;buy&#39;
@param volume total amount to sell/buy, an order could be partially executed
@param optional (nil or map[string]interface{}) with one or more of:
    @param "price" (string) price of a unit
    @param "stopPrice" (string) price to trigger a stop order
    @param "ordType" (string) &#39;limit&#39;, &#39;market&#39;, &#39;stop_limit&#39;, or &#39;stop_market&#39;
@return Order*/
func (a *PrivateApiService) PostApiV2Orders(ctx context.Context, xMAXACCESSKEY string, xMAXPAYLOAD string, xMAXSIGNATURE string, market string, side string, volume string, localVarOptionals map[string]interface{}) (Order, *http.Response, error) {
	var (
		localVarHTTPMethod = strings.ToUpper("Post")
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     Order
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	localVarPostBody := make(map[string]interface{})

	if err := typeCheckParameter(localVarOptionals["price"], "string", "price"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["stop_price"], "string", "stop_price"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["ord_type"], "string", "ord_type"); err != nil {
		return successPayload, nil, err
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-MAX-ACCESSKEY"] = parameterToString(xMAXACCESSKEY, "")
	localVarHeaderParams["X-MAX-PAYLOAD"] = parameterToString(xMAXPAYLOAD, "")
	localVarHeaderParams["X-MAX-SIGNATURE"] = parameterToString(xMAXSIGNATURE, "")
	localVarPostBody["market"] = parameterToString(market, "")
	localVarPostBody["side"] = parameterToString(side, "")
	localVarPostBody["volume"] = parameterToString(volume, "")
	if localVarTempParam, localVarOk := localVarOptionals["price"].(string); localVarOk {
		localVarPostBody["price"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["stop_price"].(string); localVarOk {
		localVarPostBody["stop_price"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["ord_type"].(string); localVarOk {
		localVarPostBody["ord_type"] = parameterToString(localVarTempParam, "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return successPayload, localVarHTTPResponse, err
	}
	defer localVarHTTPResponse.Body.Close()
	if localVarHTTPResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHTTPResponse.Body)
		return successPayload, localVarHTTPResponse, reportError("Status: %v, Body: %s", localVarHTTPResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHTTPResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHTTPResponse, err
	}

	return successPayload, localVarHTTPResponse, err
}

/* PrivateApiService
cancel all your orders with given market and side
* @param ctx context.Context for authentication, logging, tracing, etc.
@param xMAXACCESSKEY access key
@param xMAXPAYLOAD encoded payload
@param xMAXSIGNATURE encrypted signature
@param optional (nil or map[string]interface{}) with one or more of:
    @param "side" (string) set tp cancel only sell (asks) or buy (bids) orders
    @param "market" (string) specify market like btctwd / ethbtc
@return []Order*/
func (a *PrivateApiService) PostApiV2OrdersClear(ctx context.Context, xMAXACCESSKEY string, xMAXPAYLOAD string, xMAXSIGNATURE string, localVarOptionals map[string]interface{}) ([]Order, *http.Response, error) {
	var (
		localVarHTTPMethod = strings.ToUpper("Post")
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     []Order
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/orders/clear"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	localVarPostBody := make(map[string]interface{})

	if err := typeCheckParameter(localVarOptionals["side"], "string", "side"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["market"], "string", "market"); err != nil {
		return successPayload, nil, err
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-MAX-ACCESSKEY"] = parameterToString(xMAXACCESSKEY, "")
	localVarHeaderParams["X-MAX-PAYLOAD"] = parameterToString(xMAXPAYLOAD, "")
	localVarHeaderParams["X-MAX-SIGNATURE"] = parameterToString(xMAXSIGNATURE, "")
	if localVarTempParam, localVarOk := localVarOptionals["side"].(string); localVarOk {
		localVarPostBody["side"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["market"].(string); localVarOk {
		localVarPostBody["market"] = parameterToString(localVarTempParam, "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return successPayload, localVarHTTPResponse, err
	}
	defer localVarHTTPResponse.Body.Close()
	if localVarHTTPResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHTTPResponse.Body)
		return successPayload, localVarHTTPResponse, reportError("Status: %v, Body: %s", localVarHTTPResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHTTPResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHTTPResponse, err
	}

	return successPayload, localVarHTTPResponse, err
}

/* PrivateApiService create multiple sell/buy orders
create multiple sell/buy orders, please put your orders as an array in json body
* @param ctx context.Context for authentication, logging, tracing, etc.
@param xMAXACCESSKEY access key
@param xMAXPAYLOAD encoded payload
@param xMAXSIGNATURE encrypted signature
@param market unique market id, check /api/v2/markets for available markets
@param ordersSide &#39;sell&#39; or &#39;buy&#39;
@param ordersVolume total amount to sell/buy, an order could be partially executed
@param optional (nil or map[string]interface{}) with one or more of:
    @param "ordersPrice" ([]string) price of a unit
    @param "ordersStopPrice" ([]string) price to trigger a stop order
    @param "ordersOrdType" ([]string) &#39;limit&#39;, &#39;market&#39;, &#39;stop_limit&#39;, or &#39;stop_market&#39;
@return []Order*/
func (a *PrivateApiService) PostApiV2OrdersMulti(ctx context.Context, xMAXACCESSKEY string, xMAXPAYLOAD string, xMAXSIGNATURE string, market string, ordersSide []string, ordersVolume []string, localVarOptionals map[string]interface{}) ([]Order, *http.Response, error) {
	var (
		localVarHTTPMethod = strings.ToUpper("Post")
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     []Order
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/orders/multi"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	localVarPostBody := make(map[string]interface{})

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-MAX-ACCESSKEY"] = parameterToString(xMAXACCESSKEY, "")
	localVarHeaderParams["X-MAX-PAYLOAD"] = parameterToString(xMAXPAYLOAD, "")
	localVarHeaderParams["X-MAX-SIGNATURE"] = parameterToString(xMAXSIGNATURE, "")
	localVarPostBody["market"] = parameterToString(market, "")
	localVarPostBody["orders[side]"] = parameterToString(ordersSide, "csv")
	localVarPostBody["orders[volume]"] = parameterToString(ordersVolume, "csv")
	if localVarTempParam, localVarOk := localVarOptionals["orders[price]"].([]string); localVarOk {
		localVarPostBody["orders[price]"] = parameterToString(localVarTempParam, "csv")
	}
	if localVarTempParam, localVarOk := localVarOptionals["orders[stop_price]"].([]string); localVarOk {
		localVarPostBody["orders[stop_price]"] = parameterToString(localVarTempParam, "csv")
	}
	if localVarTempParam, localVarOk := localVarOptionals["orders[ord_type]"].([]string); localVarOk {
		localVarPostBody["orders[ord_type]"] = parameterToString(localVarTempParam, "csv")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return successPayload, localVarHTTPResponse, err
	}
	defer localVarHTTPResponse.Body.Close()
	if localVarHTTPResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHTTPResponse.Body)
		return successPayload, localVarHTTPResponse, reportError("Status: %v, Body: %s", localVarHTTPResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHTTPResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHTTPResponse, err
	}

	return successPayload, localVarHTTPResponse, err
}
